## Вопрос 1

### Реализация, приведенная в задании
Плюсы:
- интуитивно понятна
  
Минусы:
- вычисление модуля - сравнительно медленная операция
- громоздкая реализация для одной операции
  
### Собственная реализация
Плюсы:
- работает быстрее, т.к. работает непосредственно с битами в памяти
- лямбда-функция занимает всего одну строку

Минусы:
- не совсем проста в понимании: требуется знание побитовых операций
- для работы требуется стандарт как минимум C++11

## Вопрос 2

### Первая реализация (Q2-1)
Плюсы:
- использование "сишного" динамического массива дает больше возможностей в управлении памятью
- этот факт также немного ускоряет работу программы

Минусы:
- низкая читаемость кода: все методы определены прямо в классе
- необходимо вручную освобождать динамическую память
  
### Вторая реализация (Q2-2)
Плюсы:
- определение методов класса вне его интерфейса, что повышает читаемость кода
- использование STL-вектора облегчает написание кода и работу с контейнером

Минусы:
- немного более долгое время работы из-за использования вектора
- требуется подключение STL-библиотеки vector

## Вопрос 3

Для реализации сортировки была выбрана реализация, основанная на MergeSort, так как:
- Оптимальная асимптотическая сложность - $O(n \log n)$
- При худшем случае (когда массив отсортирован по невозрастанию) работает быстрее, чем, например, QuickSort
- В отличие от сортировок, не основанных на сравнении элементов (например, RadixSort), позволяет работать с числами разного порядка (при числах большого порядка работает даже быстрее)
- Устойчивая сортировка (одинаковые элементы не меняются местами по отношению друг к другу)
