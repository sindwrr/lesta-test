# Вопрос 1

Реализация, приведенная в задании:
+ интуитивно понятна
- вычисление модуля сравнительно долгое
- громоздкая реализация для одной операции
Собственная реализация:
+ работает быстрее, т.к. работает непосредственно с битами в памяти
+ лямбда-функция занимает всего одну строку
- не совсем проста в понимании: требуется знание побитовых операций
- для работы требуется стандарт как минимум C++11

# Вопрос 2

Q2-1:
+ использование "сишного" дин. дает больше возможностей в управлении памятью
+ этот факт также немного ускоряет работу программы 
+ простая компиляция, т.к. всего один файл
- низкая читаемость
- необходимо вручную освобождать память
Q2-2:
+ интерфейс класса и реализация методов в разных файлах: высокая читаемость кода
+ использование STL-вектора облегчает написание кода и работу с контейнером
- более сложная компиляция, т.к. две единицы трансляции
- требуется подключение STL-библиотеки vector


# Вопрос 3

Для реализации сортировки была выбрана реализация, основанная на MergeSort, т.к.:
- Оптимальная асимптотическая сложность - O(n*log n)
- При худшем случае (когда массив отсортирован по невозрастанию) работает быстрее, чем, например, QuickSort
- В отличие от сортировок, не основанных на сравнении элементов (например, RadixSort), позволяет работать с числами разного порядка (при числах большого порядке работает даже быстрее)
- Устойчивая сортировка (одинаковые элементы не меняются местами по отношению друг к другу)