## Вопрос 1

### Реализация, приведенная в задании
Плюсы:
- интуитивно понятна
  
Минусы:
- вычисление модуля - сравнительно медленная операция
- громоздкая реализация для одной операции
  
### Собственная реализация
Плюсы:
- работает быстрее, т.к. работает непосредственно с битами в памяти
- лямбда-функция занимает всего одну строку

Минусы:
- не совсем проста в понимании: требуется знание побитовых операций
- для работы требуется стандарт как минимум C++11

## Вопрос 2

### Первая реализация (Q2-1)
Плюсы:
- использование "сишного" динамического массива дает больше возможностей в управлении памятью
- этот факт также немного ускоряет работу программы
- простая компиляция, т.к. всего один файл

Минусы:
- низкая читаемость кода
- необходимо вручную освобождать память
  
### Вторая реализация (Q2-2)
Плюсы:
- интерфейс класса и реализация методов в разных файлах: высокая читаемость кода
- использование STL-вектора облегчает написание кода и работу с контейнером

Минусы:
- более сложная компиляция, т.к. две единицы трансляции
- требуется подключение STL-библиотеки vector

## Вопрос 3

Для реализации сортировки была выбрана реализация, основанная на MergeSort, так как:
- Оптимальная асимптотическая сложность - $O(n \log n)$
- При худшем случае (когда массив отсортирован по невозрастанию) работает быстрее, чем, например, QuickSort
- В отличие от сортировок, не основанных на сравнении элементов (например, RadixSort), позволяет работать с числами разного порядка (при числах большого порядке работает даже быстрее)
- Устойчивая сортировка (одинаковые элементы не меняются местами по отношению друг к другу)
